<!DOCTYPE html>
<html>
<head>
    <title>Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        #map { height: 600px; width: 100%; }
        #controls { margin: 20px; }
        #passwordModal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 300px;
        }
    </style>
</head>
<body>
    <div id="passwordModal">
        <div class="modal-content">
            <h2>Enter Password</h2>
            <input type="password" id="passwordInput">
            <button onclick="checkPassword()">Submit</button>
        </div>
    </div>

    <h3>Map</h3>
    <div id="controls">
        <label for="speedRange">Playback Speed (km/s): </label>
        <input type="range" id="speedRange" min="1" max="100" value="20" oninput="updateSpeed(this.value)">
        <span id="speedValue">20</span> km/s
        <button onclick="togglePoints()">Show Points</button>
        <button onclick="toggleAnimation()">Start Animation</button>
        <button onclick="toggleRoute()">Show Route</button>
        <button onclick="toggleDriveRoute()">Drive Route</button>
        <br><br>
        <label for="zoomIntensity">Zoom Intensity: </label>
        <input type="range" id="zoomIntensity" min="0" max="10" value="8" oninput="updateZoomIntensity(this.value)">
        <span id="zoomValue">8</span>
        <br><br>
        <label for="startDate">Start Date: </label>
        <input type="date" id="startDate">
        <label for="endDate">End Date: </label>
        <input type="date" id="endDate">
    </div>
    <div id="map"></div>

    <script>
        var map = L.map('map').setView([50.9375, 6.9603], 10);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        var routeCoordinates = [];
        var markers = [];
        var speed = 20; // km/s
        var routePath;
        var routeVisible = false;
        var pointsVisible = false;
        var animationRunning = false;
        var currentAnimationIndex = 0;
        var animationTimeout;
        var zoomIntensity = 8;
        var driveRouteRunning = false;
        var vanIcon;
        var vanMarker;

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('passwordModal').style.display = 'block';
        });

        function checkPassword() {
            var password = document.getElementById('passwordInput').value;
            if (password === 'thorsten') {
                document.getElementById('passwordModal').style.display = 'none';
                loadData();
            } else {
                alert('Incorrect password');
            }
        }

        function loadData() {
            Papa.parse('https://docs.google.com/spreadsheets/d/13nN8lisfKRQHbD66J2pg1k5jN9lFz15ijwx0obu-03o/pub?gid=0&single=true&output=csv', {
                download: true,
                header: true,
                complete: function(results) {
                    routeCoordinates = results.data
                        .map(row => ({
                            lat: parseFloat(row.lat),
                            lon: parseFloat(row.lon),
                            time: new Date(row.time)
                        }))
                        .filter(point => !isNaN(point.lat) && !isNaN(point.lon) && !isNaN(point.time.getTime()))
                        .sort((a, b) => a.time - b.time);

                    vanIcon = L.icon({
                        iconUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAC9UlEQVRoge2Zz2sTQRTHP7tJmja1tWkqVkWt4kERBRUP/gMeRMSDFz140h48efAiXjwI/h2CJw/24EFExYNIDyoIglYraqtNTZO2SZrEw0zYJN3NTrKT3UQ/EJbZmTfv+30/MztvVnAjCUwAp4Ap4AiQByaAMcDzvI0HC3QzsBKYBfLACfUI9HFgN7DRCdRe0gKOA9PAYWCzCrwN6NM0JoBzwFlgsOO6O20SeAB8Bp4B3zr0OApcBK4Aw+r6JPAQ+NglnUmXRSYDJIEfEfRKANeAi8CAun4HvHb0G0RW+THgaox7jQIn1XEjlp4uOkMh4V+ZOPAFmHb0nQIeAcWYegxEGRSXBPA9xjiTo8DZmGMD9FwA4HqA71jnkgHQAM8LCO8XH68H++w2A6+SKQzLkOyqDcfYfmuuVW8LPK9Nqylu1yBTgWoFatX/j3y9CvUaNBvQ9qHdhnabtN+GZG+FkPB3A/yvAC+I9ylULVKDVhNKe2DrYZg7Agv7YeWJfxTcWlsHPxYg+wrmD0DjNwxmX8KvJSBJCphU65iOCe9QgVqAX61CtQLv78HaKqwswGAelvbA+jpk0nLsWYLvs/D0JszvEvnaXngsrC3D4ltoNiSJLLL1nkAKlmOXFh1A5AvVKuSGJImVpYgj4fdnqK/Lyt1e//tapcWjqCO9BhVksIrQnRCX3kAlIDYTkAQAv1nGH//U6DdaYX5Bfk0mPQlOZj3JabDUxQe8DYxGXBRXZBVuVKDbArOHoLYG2ZwkMToGXgI2jMPobzh0SlazvCx7/dQQ/FyEz+/g0yv5HchKEsVd8k6Uy8HwKPgbcrZp7UBSW+aRTQW0YbG2JjvKhgH57zcl2VI5+JzGYIb+2gMl6rBxGL9WAFpRdJmuELnUFMxEZI02sBTDr25aQZFNZIBFxKGXOgfsRQqcR5AqswY8jiDeVe4Dd5B2OYPwrR2qfwaZ7B4wixQnwRxCau+jyA5zCClghpG2uYDU3v8AZWhP6R5Qw6gAAAAASUVORK5CYII=',
                        iconSize: [32, 32],
                        iconAnchor: [16, 16]
                    });

                    // Initialize controls with default values
                    document.getElementById('speedRange').value = speed;
                    document.getElementById('speedValue').textContent = speed;
                    document.getElementById('zoomIntensity').value = zoomIntensity;
                    document.getElementById('zoomValue').textContent = zoomIntensity;
                }
            });
        }

        function updateSpeed(value) {
            document.getElementById('speedValue').textContent = value;
            speed = parseInt(value);
        }

        function updateZoomIntensity(value) {
            document.getElementById('zoomValue').textContent = value;
            zoomIntensity = parseInt(value);
        }

        function togglePoints() {
            pointsVisible = !pointsVisible;
            if (pointsVisible) showPoints();
            else hidePoints();
        }

        function showPoints() {
            hidePoints();
            routeCoordinates.forEach(function(point) {
                var marker = L.marker([point.lat, point.lon]).addTo(map)
                    .bindPopup(point.time.toLocaleString());
                markers.push(marker);
            });
            map.fitBounds(L.latLngBounds(routeCoordinates.map(point => [point.lat, point.lon])));
        }

        function hidePoints() {
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
        }

        function toggleAnimation() {
            if (animationRunning) stopAnimation();
            else startAnimation();
        }

        function startAnimation() {
            if (routePath) map.removeLayer(routePath);
            routePath = L.polyline([], {color: 'blue'}).addTo(map);
            animationRunning = true;
            currentAnimationIndex = 0;
            document.querySelector('button[onclick="toggleAnimation()"]').textContent = "Stop Animation";
            animateRoute(currentAnimationIndex);
        }

        function stopAnimation() {
            animationRunning = false;
            clearTimeout(animationTimeout);
            document.querySelector('button[onclick="toggleAnimation()"]').textContent = "Start Animation";
        }

        function toggleRoute() {
            routeVisible = !routeVisible;
            if (routeVisible) showRoute();
            else if (routePath) map.removeLayer(routePath);
        }

        function showRoute() {
            if (routePath) map.removeLayer(routePath);
            getRouteFromOSRM(routeCoordinates);
        }

        function animateRoute(i) {
            if (i < routeCoordinates.length && animationRunning) {
                var point = routeCoordinates[i];
                var marker = L.marker([point.lat, point.lon]).addTo(map)
                    .bindPopup(point.time.toLocaleString())
                    .openPopup();
                markers.push(marker);

                routePath.addLatLng([point.lat, point.lon]);
                map.setView([point.lat, point.lon], calculateZoom(i));

                animationTimeout = setTimeout(function() {
                    animateRoute(i + 1);
                }, 1000);
            } else if (i >= routeCoordinates.length) {
                stopAnimation();
            }
        }

        function calculateZoom(index) {
            if (zoomIntensity === 0) return 5; // Most zoomed out
            if (index === 0 || index >= routeCoordinates.length - 1) return map.getZoom();
            
            var maxZoom = 18; // Most zoomed in
            var minZoom = 5;  // Most zoomed out
            var zoomRange = maxZoom - minZoom;
            var zoomLevel = maxZoom - (zoomIntensity / 10) * zoomRange;

            return Math.max(Math.min(zoomLevel, maxZoom), minZoom);
        }

        function toggleDriveRoute() {
            if (driveRouteRunning) stopDriveRoute();
            else startDriveRoute();
        }

        function startDriveRoute() {
            if (routePath) map.removeLayer(routePath);
            routePath = L.polyline([], {color: 'blue'}).addTo(map);
            driveRouteRunning = true;
            document.querySelector('button[onclick="toggleDriveRoute()"]').textContent = "Stop Driving";
            driveRoute(0);
        }

        function stopDriveRoute() {
            driveRouteRunning = false;
            clearTimeout(animationTimeout);
            document.querySelector('button[onclick="toggleDriveRoute()"]').textContent = "Drive Route";
            if (vanMarker) map.removeLayer(vanMarker);
        }

        function driveRoute(index) {
            if (index < routeCoordinates.length - 1 && driveRouteRunning) {
                var start = routeCoordinates[index];
                var end = routeCoordinates[index + 1];
                getRouteFromOSRM([start, end], function(route) {
                    // Check if the route significantly deviates from the main road
                    if (index > 0 && !isOnMainRoad(start, routePath.getLatLngs())) {
                        // If it deviates, find the closest point on the main route
                        var closestPoint = findClosestPointOnRoute(start, routePath.getLatLngs());
                        route.unshift(closestPoint);
                    }
                    animateVanAlongRoute(route, 0, index);
                });
            } else {
                stopDriveRoute();
            }
        }

        function animateVanAlongRoute(route, step, routeIndex) {
            if (step < route.length && driveRouteRunning) {
                var point = route[step];
                if (!vanMarker) {
                    vanMarker = L.marker(point, {icon: vanIcon}).addTo(map);
                } else {
                    vanMarker.setLatLng(point);
                }
                routePath.addLatLng(point);
                map.setView(point, calculateZoom(routeIndex));

                var timeToNextPoint = calculateTimeToNextPoint(route[step], route[step + 1] || route[step]);
                animationTimeout = setTimeout(function() {
                    animateVanAlongRoute(route, step + 1, routeIndex);
                }, timeToNextPoint);
            } else if (driveRouteRunning) {
                driveRoute(routeIndex + 1);
            }
        }

        function calculateTimeToNextPoint(point1, point2) {
            var distance = map.distance(point1, point2);
            return (distance / (speed * 1000)) * 1000; // Convert to milliseconds
        }

        function getRouteFromOSRM(points, callback) {
            var coordinates = points.map(p => p.lon + ',' + p.lat).join(';');
            var url = `https://router.project-osrm.org/route/v1/driving/${coordinates}?overview=full&geometries=geojson&continue_straight=true`;

            fetch(url)
                .then(response => response.json())
                .then(data => {
                    if (data.routes && data.routes.length > 0) {
                        var route = data.routes[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                        
                        // Simplify the route to avoid unnecessary detours
                        route = simplifyRoute(route);
                        
                        if (callback) {
                            callback(route);
                        } else {
                            routePath = L.polyline(route, {color: 'blue'}).addTo(map);
                            map.fitBounds(routePath.getBounds());
                        }
                    }
                });
        }

        function simplifyRoute(route) {
            // Implement Douglas-Peucker algorithm to simplify the route
            const tolerance = 0.0001; // Adjust this value to control the level of simplification
            if (route.length <= 2) return route;

            var maxDist = 0;
            var index = 0;
            var end = route.length - 1;

            for (var i = 1; i < end; i++) {
                var dist = pointLineDistance(route[i], route[0], route[end]);
                if (dist > maxDist) {
                    index = i;
                    maxDist = dist;
                }
            }

            if (maxDist > tolerance) {
                var results1 = simplifyRoute(route.slice(0, index + 1));
                var results2 = simplifyRoute(route.slice(index));
                return results1.slice(0, -1).concat(results2);
            } else {
                return [route[0], route[end]];
            }
        }

        function pointLineDistance(point, lineStart, lineEnd) {
            var n = Math.abs((lineEnd[1] - lineStart[1]) * point[0] - (lineEnd[0] - lineStart[0]) * point[1] + lineEnd[0] * lineStart[1] - lineEnd[1] * lineStart[0]);
            var d = Math.sqrt(Math.pow(lineEnd[1] - lineStart[1], 2) + Math.pow(lineEnd[0] - lineStart[0], 2));
            return n / d;
        }

        function isOnMainRoad(point, mainRoute) {
            const threshold = 0.001; // Adjust this value to determine how close a point needs to be to the main route
            for (let i = 0; i < mainRoute.length - 1; i++) {
                if (pointLineDistance(point, mainRoute[i], mainRoute[i + 1]) < threshold) {
                    return true;
                }
            }
            return false;
        }

        function findClosestPointOnRoute(point, route) {
            var minDist = Infinity;
            var closestPoint = null;
            for (var i = 0; i < route.length; i++) {
                var dist = map.distance(point, route[i]);
                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = route[i];
                }
            }
            return closestPoint;
        }
    </script>
</body>
</html>
